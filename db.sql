CREATE TABLE user_account (
    user_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    login_code VARCHAR2(30) UNIQUE NOT NULL,
    password_hash VARCHAR2(255) NOT NULL,
    role VARCHAR2(10) NOT NULL,
    status VARCHAR2(10) DEFAULT 'ACTIVE',
    CONSTRAINT chk_user_role 
        CHECK (role IN ('STUDENT','PROF','ADMIN'))
);
CREATE TABLE departement (
    departement_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) UNIQUE NOT NULL
);
CREATE TABLE filiere (
    filiere_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) NOT NULL,
    departement_id NUMBER NOT NULL,
    CONSTRAINT fk_filiere_departement
        FOREIGN KEY (departement_id)
        REFERENCES departement(departement_id)
);
CREATE TABLE academic_year (
    year_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    label VARCHAR2(20) UNIQUE NOT NULL,
    start_date DATE,
    end_date DATE
);
CREATE TABLE semestre (
    semestre_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code VARCHAR2(5) NOT NULL,
    filiere_id NUMBER NOT NULL,
    year_id NUMBER NOT NULL,
    CONSTRAINT fk_sem_filiere
        FOREIGN KEY (filiere_id)
        REFERENCES filiere(filiere_id),
    CONSTRAINT fk_sem_year
        FOREIGN KEY (year_id)
        REFERENCES academic_year(year_id)
);
CREATE TABLE student (
    student_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code_apoge VARCHAR2(30) UNIQUE NOT NULL,
    full_name VARCHAR2(100),
    filiere_id NUMBER,
    current_semestre_id NUMBER,
    CONSTRAINT fk_student_user
        FOREIGN KEY (code_apoge)
        REFERENCES user_account(login_code),
    CONSTRAINT fk_student_filiere
        FOREIGN KEY (filiere_id)
        REFERENCES filiere(filiere_id),
    CONSTRAINT fk_student_semestre
        FOREIGN KEY (current_semestre_id)
        REFERENCES semestre(semestre_id)
);
CREATE TABLE prof (
    prof_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code_apoge VARCHAR2(30) UNIQUE NOT NULL,
    full_name VARCHAR2(100),
    departement_id NUMBER,
    CONSTRAINT fk_prof_user
        FOREIGN KEY (code_apoge)
        REFERENCES user_account(login_code),
    CONSTRAINT fk_prof_departement
        FOREIGN KEY (departement_id)
        REFERENCES departement(departement_id)
);
CREATE TABLE admin (
    admin_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR2(30) UNIQUE NOT NULL,
    full_name VARCHAR2(100),
    CONSTRAINT fk_admin_user
        FOREIGN KEY (username)
        REFERENCES user_account(login_code)
);
CREATE TABLE course (
    course_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    filiere_id NUMBER NOT NULL,
    semestre_id NUMBER NOT NULL,
    capacity NUMBER DEFAULT 30,
    CONSTRAINT fk_course_filiere
        FOREIGN KEY (filiere_id)
        REFERENCES filiere(filiere_id),
    CONSTRAINT fk_course_semestre
        FOREIGN KEY (semestre_id)
        REFERENCES semestre(semestre_id)
);
CREATE TABLE course_prerequisite (
    course_id NUMBER,
    prerequisite_course_id NUMBER,
    CONSTRAINT pk_course_prereq PRIMARY KEY (course_id, prerequisite_course_id),
    CONSTRAINT fk_pr_course
        FOREIGN KEY (course_id)
        REFERENCES course(course_id),
    CONSTRAINT fk_pr_prereq
        FOREIGN KEY (prerequisite_course_id)
        REFERENCES course(course_id)
);
CREATE TABLE prof_course (
    prof_id NUMBER,
    course_id NUMBER,
    CONSTRAINT pk_prof_course PRIMARY KEY (prof_id, course_id),
    CONSTRAINT fk_pc_prof
        FOREIGN KEY (prof_id)
        REFERENCES prof(prof_id),
    CONSTRAINT fk_pc_course
        FOREIGN KEY (course_id)
        REFERENCES course(course_id)
);
CREATE TABLE inscription_request (
    request_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    course_id NUMBER NOT NULL,
    status VARCHAR2(15) DEFAULT 'PENDING',
    request_date DATE DEFAULT SYSDATE,
    CONSTRAINT chk_request_status
        CHECK (status IN ('PENDING','ACCEPTED','REJECTED')),
    CONSTRAINT fk_req_student
        FOREIGN KEY (student_id)
        REFERENCES student(student_id),
    CONSTRAINT fk_req_course
        FOREIGN KEY (course_id)
        REFERENCES course(course_id)
);
CREATE TABLE course_result (
    student_id NUMBER,
    course_id NUMBER,
    semestre_id NUMBER,
    year_id NUMBER,
    grade NUMBER(4,2),
    status VARCHAR2(10),
    CONSTRAINT pk_course_result PRIMARY KEY (student_id, course_id),
    CONSTRAINT chk_result_status
        CHECK (status IN ('IN_PROGRESS','VALID','FAILED')),
    CONSTRAINT fk_res_student
        FOREIGN KEY (student_id)
        REFERENCES student(student_id),
    CONSTRAINT fk_res_course
        FOREIGN KEY (course_id)
        REFERENCES course(course_id),
    CONSTRAINT fk_res_semestre
        FOREIGN KEY (semestre_id)
        REFERENCES semestre(semestre_id),
    CONSTRAINT fk_res_year
        FOREIGN KEY (year_id)
        REFERENCES academic_year(year_id)
);
CREATE TABLE section (
    section_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(30),
    filiere_id NUMBER,
    semestre_id NUMBER,
    CONSTRAINT fk_section_filiere
        FOREIGN KEY (filiere_id)
        REFERENCES filiere(filiere_id),
    CONSTRAINT fk_section_semestre
        FOREIGN KEY (semestre_id)
        REFERENCES semestre(semestre_id)
);
CREATE TABLE student_section (
    student_id NUMBER,
    section_id NUMBER,
    CONSTRAINT pk_student_section PRIMARY KEY (student_id, section_id),
    CONSTRAINT fk_ss_student
        FOREIGN KEY (student_id)
        REFERENCES student(student_id),
    CONSTRAINT fk_ss_section
        FOREIGN KEY (section_id)
        REFERENCES section(section_id)
);
CREATE TABLE seance (
    seance_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    course_id NUMBER NOT NULL,
    section_id NUMBER NOT NULL,
    seance_date DATE NOT NULL,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    room VARCHAR2(50),
    type VARCHAR2(10),
    CONSTRAINT chk_seance_type
        CHECK (type IN ('COURS','TD','TP')),
    CONSTRAINT fk_seance_course
        FOREIGN KEY (course_id)
        REFERENCES course(course_id),
    CONSTRAINT fk_seance_section
        FOREIGN KEY (section_id)
        REFERENCES section(section_id)
);
CREATE TABLE attendance (
    seance_id NUMBER,
    student_id NUMBER,
    status VARCHAR2(10),
    marked_at DATE DEFAULT SYSDATE,
    CONSTRAINT pk_attendance PRIMARY KEY (seance_id, student_id),
    CONSTRAINT chk_attendance_status
        CHECK (status IN ('PLANNED','PRESENT','ABSENT','LATE','ABSENT AVEC JUSTIFICATION')),
    CONSTRAINT fk_att_seance
        FOREIGN KEY (seance_id)
        REFERENCES seance(seance_id),
    CONSTRAINT fk_att_student
        FOREIGN KEY (student_id)
        REFERENCES student(student_id)
);
CREATE TABLE unblock_request (
    unblock_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    course_id NUMBER NOT NULL,
    admin_id NUMBER NOT NULL,
    justification VARCHAR2(500) NOT NULL,
    unblock_date DATE DEFAULT SYSDATE
);

CREATE OR REPLACE TRIGGER trg_prof_max_3_courses
BEFORE INSERT ON prof_course
FOR EACH ROW
DECLARE
    v_new_course_year_id NUMBER;
    v_count_in_year      NUMBER;
BEGIN
    -- 1. Find the academic year of the new course being assigned.
    SELECT s.YEAR_ID
    INTO v_new_course_year_id
    FROM COURSE c
    JOIN SEMESTRE s ON c.SEMESTRE_ID = s.SEMESTRE_ID
    WHERE c.COURSE_ID = :NEW.course_id;

    -- 2. Count how many courses the professor already has in THAT specific year.
    SELECT COUNT(*)
    INTO v_count_in_year
    FROM prof_course pc
    JOIN course c ON pc.course_id = c.course_id
    JOIN semestre s ON c.semestre_id = c.semestre_id
    WHERE pc.prof_id = :NEW.prof.prof_id -- This is a typo in the replace string, should be :NEW.prof_id
      AND s.year_id = v_new_course_year_id;

    -- 3. Check if the count is already 3 or more.
    IF v_count_in_year >= 3 THEN
        RAISE_APPLICATION_ERROR(
            -20001,
            'Ce professeur a déjà 3 cours affectés pour cette année académique (maximum autorisé par an)'
        );
    END IF;
END;
/
CREATE OR REPLACE TRIGGER trg_max_7_courses_per_semestre
BEFORE INSERT ON course
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM course
    WHERE filiere_id = :NEW.filiere_id
      AND semestre_id = :NEW.semestre_id;

    IF v_count >= 7 THEN
        RAISE_APPLICATION_ERROR(
            -20002,
            'Maximum 7 cours autorisés par filière et semestre'
        );
    END IF;
END;
/
CREATE OR REPLACE TRIGGER trg_check_prerequisite
BEFORE INSERT ON inscription_request
FOR EACH ROW
DECLARE
    v_missing NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_missing
    FROM course_prerequisite cp
    WHERE cp.course_id = :NEW.course_id
      AND NOT EXISTS (
          SELECT 1
          FROM course_result cr
          WHERE cr.student_id = :NEW.student_id
            AND cr.course_id = cp.prerequisite_course_id
            AND cr.status = 'VALID'
      );

    IF v_missing > 0 THEN
        RAISE_APPLICATION_ERROR(
            -20003,
            'Inscription refusée : prérequis non validé'
        );
    END IF;
END;
/
CREATE OR REPLACE TRIGGER trg_check_seance_overlap
BEFORE INSERT OR UPDATE ON seance
FOR EACH ROW
DECLARE
    v_prof_conflict   NUMBER;
    v_room_conflict   NUMBER;
    v_prof_id         NUMBER;
BEGIN
    -- Find the professor for the course of the new seance
    BEGIN
        SELECT prof_id INTO v_prof_id
        FROM prof_course
        WHERE course_id = :NEW.course_id
        AND ROWNUM = 1; -- A course might have multiple profs in theory, take the first one
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_prof_id := NULL; -- No professor assigned to this course
    END;
    
    -- Check for professor overlap if a professor is assigned
    IF v_prof_id IS NOT NULL THEN
        SELECT COUNT(*)
        INTO v_prof_conflict
        FROM seance s
        JOIN prof_course pc ON s.course_id = pc.course_id
        WHERE pc.prof_id = v_prof_id
          AND s.seance_date = :NEW.seance_date
          AND s.seance_id != :NEW.seance_id -- Exclude self in case of update
          AND (:NEW.start_time < s.end_time AND :NEW.end_time > s.start_time);
          
        IF v_prof_conflict > 0 THEN
            RAISE_APPLICATION_ERROR(-20010, 'Professor has a time conflict with another session.');
        END IF;
    END IF;

    -- Check for room overlap
    SELECT COUNT(*)
    INTO v_room_conflict
    FROM seance s
    WHERE s.room = :NEW.room
      AND s.seance_date = :NEW.seance_date
      AND s.seance_id != :NEW.seance_id -- Exclude self in case of update
      AND (:NEW.start_time < s.end_time AND :NEW.end_time > s.start_time);

    IF v_room_conflict > 0 THEN
        RAISE_APPLICATION_ERROR(-20011, 'Room is already booked for an overlapping time slot on this day.');
    END IF;
END;
/
CREATE OR REPLACE TRIGGER trg_3_consecutive_absences
FOR INSERT OR UPDATE ON attendance
COMPOUND TRIGGER

    TYPE AttendanceInfo_tab IS TABLE OF attendance%ROWTYPE INDEX BY PLS_INTEGER;
    g_attendance_changes AttendanceInfo_tab;
    g_idx PLS_INTEGER := 0;

    AFTER EACH ROW IS
    BEGIN
        g_idx := g_idx + 1;
        g_attendance_changes(g_idx).seance_id := :NEW.seance_id;
        g_attendance_changes(g_idx).student_id := :NEW.student_id;
        g_attendance_changes(g_idx).status := :NEW.status;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
        v_course_id NUMBER;
        v_absent_count NUMBER;
    BEGIN
        FOR i IN 1 .. g_attendance_changes.COUNT LOOP
            DECLARE
                current_seance_id NUMBER := g_attendance_changes(i).seance_id;
                current_student_id NUMBER := g_attendance_changes(i).student_id;
                current_status VARCHAR2(10) := g_attendance_changes(i).status;
            BEGIN
                IF current_status = 'ABSENT' THEN
                    SELECT course_id INTO v_course_id
                    FROM seance
                    WHERE seance_id = current_seance_id;

                    SELECT COUNT(*)
                    INTO v_absent_count
                    FROM (
                        SELECT a.status
                        FROM attendance a
                        JOIN seance s ON s.seance_id = a.seance_id
                        WHERE a.student_id = current_student_id
                          AND s.course_id = v_course_id
                        ORDER BY s.seance_date DESC, s.start_time DESC
                        FETCH FIRST 3 ROWS ONLY
                    )
                    WHERE status = 'ABSENT';

                    IF v_absent_count = 3 THEN
                        UPDATE course_result
                        SET status = 'FAILED'
                        WHERE student_id = current_student_id
                          AND course_id = v_course_id;
                    END IF;
                END IF;
            END;
        END LOOP;
    END AFTER STATEMENT;

END;
/
CREATE OR REPLACE TRIGGER trg_block_after_3_absences
FOR INSERT OR UPDATE ON attendance
COMPOUND TRIGGER

    TYPE AttendanceInfo_tab IS TABLE OF attendance%ROWTYPE INDEX BY PLS_INTEGER;
    g_attendance_changes AttendanceInfo_tab;
    g_idx PLS_INTEGER := 0;

    AFTER EACH ROW IS
    BEGIN
        g_idx := g_idx + 1;
        g_attendance_changes(g_idx).seance_id := :NEW.seance_id;
        g_attendance_changes(g_idx).student_id := :NEW.student_id;
        g_attendance_changes(g_idx).status := :NEW.status;
        g_attendance_changes(g_idx).marked_at := :NEW.marked_at;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
        v_course_id       NUMBER;
        v_absent_count    NUMBER;
        v_last_unblock    DATE;
    BEGIN
        FOR i IN 1 .. g_attendance_changes.COUNT LOOP
            DECLARE
                current_seance_id NUMBER := g_attendance_changes(i).seance_id;
                current_student_id NUMBER := g_attendance_changes(i).student_id;
                current_status VARCHAR2(10) := g_attendance_changes(i).status;
                current_marked_at DATE := g_attendance_changes(i).marked_at;
            BEGIN
                IF current_status = 'ABSENT' THEN
                    SELECT course_id INTO v_course_id
                    FROM seance
                    WHERE seance_id = current_seance_id;

                    SELECT MAX(unblock_date)
                    INTO v_last_unblock
                    FROM unblock_request
                    WHERE student_id = current_student_id
                      AND course_id  = v_course_id;

                    SELECT COUNT(*)
                    INTO v_absent_count
                    FROM (
                        SELECT a.status, a.marked_at
                        FROM attendance a
                        JOIN seance s ON s.seance_id = a.seance_id
                        WHERE a.student_id = current_student_id
                          AND s.course_id  = v_course_id
                          AND a.status     = 'ABSENT'
                          AND (v_last_unblock IS NULL OR a.marked_at > v_last_unblock)
                        ORDER BY s.seance_date DESC, s.start_time DESC
                    )
                    WHERE ROWNUM <= 3;

                    IF v_absent_count = 3 THEN
                        RAISE_APPLICATION_ERROR(
                            -20210,
                            'Étudiant bloqué : 3 absences consécutives (non justifiées)'
                        );
                    END IF;
                END IF;
            END;
        END LOOP;
    END AFTER STATEMENT;

END;
/

CREATE OR REPLACE PROCEDURE admin_unblock_student (
    p_student_id     IN NUMBER,
    p_course_id      IN NUMBER,
    p_admin_id       IN NUMBER,
    p_justification  IN VARCHAR2
) IS
    v_exists NUMBER;
BEGIN
    -- 1️⃣ Vérifier que l'étudiant est bloqué
    SELECT COUNT(*)
    INTO v_exists
    FROM course_result
    WHERE student_id = p_student_id
      AND course_id = p_course_id
      AND status = 'FAILED';

    IF v_exists = 0 THEN
        RAISE_APPLICATION_ERROR(
            -20030,
            'Déblocage impossible : étudiant non bloqué'
        );
    END IF;

    -- 2️⃣ Vérifier justification
    IF p_justification IS NULL OR LENGTH(p_justification) < 10 THEN
        RAISE_APPLICATION_ERROR(
            -20031,
            'Justification insuffisante (minimum 10 caractères)'
        );
    END IF;

    -- 3️⃣ Audit (on garde trace)
    INSERT INTO unblock_request (
        student_id,
        course_id,
        admin_id,
        justification
    )
    VALUES (
        p_student_id,
        p_course_id,
        p_admin_id,
        p_justification
    );

    -- 4️⃣ Déblocage académique
    UPDATE course_result
    SET status = 'IN_PROGRESS'
    WHERE student_id = p_student_id
      AND course_id = p_course_id;

    COMMIT;
END;
/
CREATE OR REPLACE TRIGGER trg_justify_absences_after_unblock
AFTER INSERT ON unblock_request
FOR EACH ROW
BEGIN
    -- نحولو آخر 3 absences ديال الطالب فداك cours
    UPDATE attendance a
    SET a.status = 'ABSENT AVEC JUSTIFICATION'
    WHERE a.student_id = :NEW.student_id
      AND a.status = 'ABSENT'
      AND a.seance_id IN (
          SELECT seance_id
          FROM (
              SELECT se.seance_id
              FROM attendance at
              JOIN seance se ON se.seance_id = at.seance_id
              WHERE at.student_id = :NEW.student_id
                AND at.status = 'ABSENT'
                AND se.course_id = :NEW.course_id
              ORDER BY se.seance_date DESC, se.start_time DESC
          )
          WHERE ROWNUM <= 3
      );
END;
/
CREATE OR REPLACE VIEW v_detail_student AS
SELECT
    s.student_id,
    s.code_apoge,
    s.full_name,
    f.name AS filiere,
    sem.code AS semestre,
    ua.status AS account_status
FROM student s
JOIN filiere f ON f.filiere_id = s.filiere_id
JOIN semestre sem ON sem.semestre_id = s.current_semestre_id
JOIN user_account ua ON ua.login_code = s.code_apoge;
CREATE OR REPLACE VIEW v_detail_departement AS
SELECT
    d.departement_id,
    d.name AS departement,
    COUNT(DISTINCT f.filiere_id) AS total_filieres,
    COUNT(DISTINCT p.prof_id) AS total_profs
FROM departement d
LEFT JOIN filiere f ON f.departement_id = d.departement_id
LEFT JOIN prof p ON p.departement_id = d.departement_id
GROUP BY d.departement_id, d.name;
CREATE OR REPLACE VIEW v_detail_course AS
SELECT
    c.course_id,
    c.name AS course_name,
    f.name AS filiere,
    s.code AS semestre,
    p.full_name AS prof_name,
    c.capacity
FROM course c
JOIN filiere f ON f.filiere_id = c.filiere_id
JOIN semestre s ON s.semestre_id = c.semestre_id
LEFT JOIN prof_course pc ON pc.course_id = c.course_id
LEFT JOIN prof p ON p.prof_id = pc.prof_id;
CREATE OR REPLACE VIEW v_detail_prerequisite_course AS
SELECT
    c.name AS course,
    cp.name AS prerequisite
FROM course_prerequisite pr
JOIN course c ON c.course_id = pr.course_id
JOIN course cp ON cp.course_id = pr.prerequisite_course_id;
CREATE OR REPLACE VIEW v_detail_filiere AS
SELECT
    f.filiere_id,
    f.name AS filiere,
    d.name AS departement,
    COUNT(s.semestre_id) AS total_semestres
FROM filiere f
JOIN departement d ON d.departement_id = f.departement_id
LEFT JOIN semestre s ON s.filiere_id = f.filiere_id
GROUP BY f.filiere_id, f.name, d.name;
CREATE OR REPLACE VIEW v_detail_seance_course AS
SELECT
    se.seance_id,
    c.name AS course,
    sec.name AS section,
    se.seance_date,
    se.start_time,
    se.end_time,
    se.type
FROM seance se
JOIN course c ON c.course_id = se.course_id
JOIN section sec ON sec.section_id = se.section_id;
CREATE OR REPLACE VIEW v_detail_student_blocked AS
SELECT
    s.student_id,
    s.full_name,
    c.course_id,
    c.name AS course,
    cr.status
FROM course_result cr
JOIN student s ON s.student_id = cr.student_id
JOIN course c ON c.course_id = cr.course_id
WHERE cr.status = 'FAILED';
CREATE OR REPLACE VIEW v_dashboard_stats AS
SELECT
    (SELECT COUNT(*) FROM student) AS total_students,
    (SELECT COUNT(*) FROM prof) AS total_profs,
    (SELECT COUNT(*) FROM course) AS total_courses,
    (SELECT COUNT(*) FROM student s JOIN course_result cr
     ON s.student_id = cr.student_id
     WHERE cr.status = 'FAILED') AS blocked_students
FROM dual;
CREATE OR REPLACE VIEW v_students_warning AS
SELECT DISTINCT
    s.student_id,
    s.full_name,
    c.name AS course
FROM attendance a
JOIN seance se ON se.seance_id = a.seance_id
JOIN course c ON c.course_id = se.course_id
JOIN student s ON s.student_id = a.student_id
WHERE a.status = 'ABSENT'
GROUP BY s.student_id, s.full_name, c.name
HAVING COUNT(*) >= 2;
CREATE OR REPLACE VIEW v_course_attendance_rate AS
SELECT
    c.name AS course,
    ROUND(
        SUM(CASE WHEN a.status = 'PRESENT' THEN 1 ELSE 0 END)
        / COUNT(a.student_id) * 100, 2
    ) AS attendance_rate
FROM attendance a
JOIN seance s ON s.seance_id = a.seance_id
JOIN course c ON c.course_id = s.course_id
GROUP BY c.name;
CREATE OR REPLACE FUNCTION fn_student_current_courses (
    p_student_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            c.course_id,
            c.name        AS course_name,
            sem.code      AS semestre,
            cr.status     AS course_status,
            se.seance_id,
            se.seance_date,
            se.start_time,
            se.end_time,
            se.type
        FROM student st
        JOIN semestre sem ON sem.semestre_id = st.current_semestre_id
        JOIN course c ON c.semestre_id = sem.semestre_id
        LEFT JOIN course_result cr
               ON cr.student_id = st.student_id
              AND cr.course_id  = c.course_id
        LEFT JOIN seance se ON se.course_id = c.course_id
        WHERE st.student_id = p_student_id;
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_prof_courses (
    p_prof_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            c.course_id,
            c.name AS course_name,
            se.seance_id,
            se.seance_date,
            se.start_time,
            se.end_time,
            se.type
        FROM prof_course pc
        JOIN course c ON c.course_id = pc.course_id
        LEFT JOIN seance se ON se.course_id = c.course_id
        WHERE pc.prof_id = p_prof_id;
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_course_prerequisites (
    p_course_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            cp.course_id,
            c2.course_id AS prerequisite_id,
            c2.name      AS prerequisite_name
        FROM course_prerequisite cp
        JOIN course c2
          ON c2.course_id = cp.prerequisite_course_id
        WHERE cp.course_id = p_course_id;
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_students_present_in_seance (
    p_seance_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            st.student_id,
            st.full_name,
            a.status
        FROM attendance a
        JOIN student st ON st.student_id = a.student_id
        WHERE a.seance_id = p_seance_id
          AND a.status = 'PRESENT';
    RETURN rc;
END;
/
CREATE OR REPLACE TRIGGER trg_block_missing_prerequisite
BEFORE INSERT OR UPDATE ON inscription_request
FOR EACH ROW
DECLARE
    v_missing NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_missing
    FROM course_prerequisite cp
    WHERE cp.course_id = :NEW.course_id
      AND NOT EXISTS (
          SELECT 1
          FROM course_result cr
          WHERE cr.student_id = :NEW.student_id
            AND cr.course_id  = cp.prerequisite_course_id
            AND cr.status     = 'VALID'
      );

    IF v_missing > 0 THEN
        RAISE_APPLICATION_ERROR(
            -20050,
            'Inscription bloquée : prérequis non validé'
        );
    END IF;
END;
/
CREATE OR REPLACE TRIGGER trg_accept_inscription_init_attendance
AFTER UPDATE ON inscription_request
FOR EACH ROW
WHEN (OLD.status <> 'ACCEPTED' AND NEW.status = 'ACCEPTED')
BEGIN
    INSERT INTO attendance (seance_id, student_id, status)
    SELECT
        se.seance_id,
        :NEW.student_id,
        'PLANNED'
    FROM seance se
    WHERE se.course_id = :NEW.course_id;
END;
/
CREATE OR REPLACE VIEW v_student_current_courses AS
SELECT
    st.student_id,
    c.course_id,
    c.name        AS course_name,
    sem.code      AS semestre,
    NVL(cr.status, 'IN_PROGRESS') AS course_status
FROM student st
JOIN semestre sem 
    ON sem.semestre_id = st.current_semestre_id
JOIN course c 
    ON c.semestre_id = sem.semestre_id
LEFT JOIN course_result cr
    ON cr.student_id = st.student_id
   AND cr.course_id  = c.course_id;
CREATE OR REPLACE VIEW v_student_course_seances AS
SELECT
    st.student_id,
    c.name        AS course_name,
    se.seance_id,
    se.seance_date,
    se.start_time,
    se.end_time,
    se.type
FROM student st
JOIN course c
    ON c.semestre_id = st.current_semestre_id
JOIN seance se
    ON se.course_id = c.course_id;
CREATE OR REPLACE VIEW v_student_attendance AS
SELECT
    a.student_id,
    c.name        AS course_name,
    se.seance_date,
    se.type,
    a.status
FROM attendance a
JOIN seance se 
    ON se.seance_id = a.seance_id
JOIN course c
    ON c.course_id = se.course_id;
CREATE OR REPLACE VIEW v_student_absence_stats AS
SELECT
    a.student_id,
    c.name AS course_name,
    COUNT(*) AS total_seances,
    SUM(CASE WHEN a.status = 'ABSENT' THEN 1 ELSE 0 END) AS absences
FROM attendance a
JOIN seance se 
    ON se.seance_id = a.seance_id
JOIN course c 
    ON c.course_id = se.course_id
GROUP BY a.student_id, c.name;
CREATE OR REPLACE VIEW v_student_blocked_courses AS
SELECT
    cr.student_id,
    c.name AS course_name,
    cr.status
FROM course_result cr
JOIN course c
    ON c.course_id = cr.course_id
WHERE cr.status = 'FAILED';
CREATE OR REPLACE VIEW v_student_prerequisite_missing AS
SELECT
    st.student_id,
    c.name AS blocked_course,
    cp2.name AS missing_prerequisite
FROM student st
JOIN course c 
    ON c.semestre_id = st.current_semestre_id
JOIN course_prerequisite cp
    ON cp.course_id = c.course_id
JOIN course cp2
    ON cp2.course_id = cp.prerequisite_course_id
LEFT JOIN course_result cr
    ON cr.student_id = st.student_id
   AND cr.course_id  = cp.prerequisite_course_id
   AND cr.status     = 'VALID'
WHERE cr.course_id IS NULL;
CREATE OR REPLACE VIEW v_student_dashboard_summary AS
SELECT
    st.student_id,
    COUNT(DISTINCT c.course_id) AS total_courses,
    SUM(CASE WHEN cr.status = 'FAILED' THEN 1 ELSE 0 END) AS blocked_courses,
    SUM(CASE WHEN a.status = 'ABSENT' THEN 1 ELSE 0 END) AS total_absences
FROM student st
LEFT JOIN course c
    ON c.semestre_id = st.current_semestre_id
LEFT JOIN course_result cr
    ON cr.student_id = st.student_id
   AND cr.course_id  = c.course_id
LEFT JOIN attendance a
    ON a.student_id = st.student_id
GROUP BY st.student_id;
CREATE OR REPLACE FUNCTION fn_student_courses (
    p_student_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            c.course_id,
            c.name AS course_name,
            sem.code AS semestre,
            NVL(cr.status, 'IN_PROGRESS') AS course_status
        FROM student st
        JOIN semestre sem
            ON sem.semestre_id = st.current_semestre_id
        JOIN course c
            ON c.semestre_id = sem.semestre_id
        LEFT JOIN course_result cr
            ON cr.student_id = st.student_id
           AND cr.course_id = c.course_id
        WHERE st.student_id = p_student_id;
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_student_seances (
    p_student_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            c.name AS course_name,
            se.seance_id,
            se.seance_date,
            se.start_time,
            se.end_time,
            se.type,
            a.status
        FROM student st
        JOIN course c
            ON c.semestre_id = st.current_semestre_id
        JOIN seance se
            ON se.course_id = c.course_id
        LEFT JOIN attendance a
            ON a.seance_id = se.seance_id
           AND a.student_id = st.student_id
        WHERE st.student_id = p_student_id;
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_student_blocked_courses (
    p_student_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            c.course_id,
            c.name AS course_name,
            cr.status
        FROM course_result cr
        JOIN course c ON c.course_id = cr.course_id
        WHERE cr.student_id = p_student_id
          AND cr.status = 'FAILED';
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_missing_prerequisites (
    p_student_id IN NUMBER,
    p_course_id  IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            c2.course_id,
            c2.name AS prerequisite_name
        FROM course_prerequisite cp
        JOIN course c2
            ON c2.course_id = cp.prerequisite_course_id
        WHERE cp.course_id = p_course_id
          AND NOT EXISTS (
              SELECT 1
              FROM course_result cr
              WHERE cr.student_id = p_student_id
                AND cr.course_id = c2.course_id
                AND cr.status = 'VALID'
          );
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_prof_courses (
    p_prof_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            c.course_id,
            c.name AS course_name,
            sem.code AS semestre
        FROM prof_course pc
        JOIN course c ON c.course_id = pc.course_id
        JOIN semestre sem ON sem.semestre_id = c.semestre_id
        WHERE pc.prof_id = p_prof_id;
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_prof_seances (
    p_prof_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            c.name AS course_name,
            se.seance_id,
            se.seance_date,
            se.start_time,
            se.end_time,
            se.type
        FROM prof_course pc
        JOIN course c ON c.course_id = pc.course_id
        JOIN seance se ON se.course_id = c.course_id
        WHERE pc.prof_id = p_prof_id;
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_students_in_seance (
    p_seance_id IN NUMBER
) RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            st.student_id,
            st.full_name,
            a.status
        FROM attendance a
        JOIN student st ON st.student_id = a.student_id
        WHERE a.seance_id = p_seance_id;
    RETURN rc;
END;
/
CREATE OR REPLACE FUNCTION fn_blocked_students
RETURN SYS_REFCURSOR
IS
    rc SYS_REFCURSOR;
BEGIN
    OPEN rc FOR
        SELECT
            s.student_id,
            s.full_name,
            c.name AS course_name
        FROM course_result cr
        JOIN student s ON s.student_id = cr.student_id
        JOIN course c ON c.course_id = cr.course_id
        WHERE cr.status = 'FAILED';
    RETURN rc;
END;
/
CREATE OR REPLACE VIEW v_prof_courses AS
SELECT
    p.prof_id,
    p.full_name        AS prof_name,
    c.course_id,
    c.name             AS course_name,
    f.name             AS filiere,
    sem.code           AS semestre
FROM prof p
JOIN prof_course pc   ON pc.prof_id = p.prof_id
JOIN course c         ON c.course_id = pc.course_id
JOIN filiere f        ON f.filiere_id = c.filiere_id
JOIN semestre sem     ON sem.semestre_id = c.semestre_id;
CREATE OR REPLACE VIEW v_prof_seances AS
SELECT
    p.prof_id,
    c.name        AS course_name,
    se.seance_id,
    se.seance_date,
    se.start_time,
    se.end_time,
    se.type,
    sec.name      AS section
FROM prof p
JOIN prof_course pc ON pc.prof_id = p.prof_id
JOIN course c       ON c.course_id = pc.course_id
JOIN seance se      ON se.course_id = c.course_id
JOIN section sec    ON sec.section_id = se.section_id;
CREATE OR REPLACE VIEW v_prof_students_by_course AS
SELECT DISTINCT
    p.prof_id,
    c.course_id,
    c.name        AS course_name,
    st.student_id,
    st.full_name
FROM prof p
JOIN prof_course pc      ON pc.prof_id = p.prof_id
JOIN course c            ON c.course_id = pc.course_id
JOIN inscription_request ir
    ON ir.course_id = c.course_id
   AND ir.status = 'ACCEPTED'
JOIN student st          ON st.student_id = ir.student_id;
CREATE OR REPLACE VIEW v_prof_attendance_by_seance AS
SELECT
    p.prof_id,
    se.seance_id,
    c.name        AS course_name,
    st.student_id,
    st.full_name,
    a.status
FROM prof p
JOIN prof_course pc ON pc.prof_id = p.prof_id
JOIN course c       ON c.course_id = pc.course_id
JOIN seance se      ON se.course_id = c.course_id
JOIN attendance a   ON a.seance_id = se.seance_id
JOIN student st     ON st.student_id = a.student_id;
CREATE OR REPLACE VIEW v_prof_absence_stats AS
SELECT
    p.prof_id,
    c.name AS course_name,
    COUNT(*) AS total_records,
    SUM(CASE WHEN a.status = 'ABSENT' THEN 1 ELSE 0 END) AS total_absences
FROM prof p
JOIN prof_course pc ON pc.prof_id = p.prof_id
JOIN course c       ON c.course_id = pc.course_id
JOIN seance se      ON se.course_id = c.course_id
JOIN attendance a   ON a.seance_id = se.seance_id
GROUP BY p.prof_id, c.name;
CREATE OR REPLACE VIEW v_prof_blocked_students AS
SELECT
    p.prof_id,
    st.student_id,
    st.full_name,
    c.name AS course_name,
    cr.status
FROM prof p
JOIN prof_course pc ON pc.prof_id = p.prof_id
JOIN course c       ON c.course_id = pc.course_id
JOIN course_result cr
    ON cr.course_id = c.course_id
   AND cr.status = 'FAILED'
JOIN student st     ON st.student_id = cr.student_id;
CREATE OR REPLACE VIEW v_prof_dashboard_summary AS
SELECT
    p.prof_id,
    COUNT(DISTINCT c.course_id) AS total_courses,
    COUNT(DISTINCT se.seance_id) AS total_seances,
    COUNT(DISTINCT st.student_id) AS total_students
FROM prof p
LEFT JOIN prof_course pc ON pc.prof_id = p.prof_id
LEFT JOIN course c       ON c.course_id = pc.course_id
LEFT JOIN seance se      ON se.course_id = c.course_id
LEFT JOIN inscription_request ir
    ON ir.course_id = c.course_id
   AND ir.status = 'ACCEPTED'
LEFT JOIN student st     ON st.student_id = ir.student_id
GROUP BY p.prof_id;
CREATE INDEX idx_attendance_student ON attendance(student_id);
CREATE INDEX idx_attendance_seance ON attendance(seance_id);
CREATE INDEX idx_course_semestre ON course(semestre_id);
CREATE INDEX idx_inscription_status ON inscription_request(status);
-- هاد التريكر كيمنع قبول أي طالب جديد إلا القسم وصل للحد الأقصى (Capacity)
CREATE OR REPLACE TRIGGER trg_check_course_capacity
BEFORE UPDATE ON inscription_request
FOR EACH ROW
WHEN (NEW.status = 'ACCEPTED' AND OLD.status <> 'ACCEPTED')
DECLARE
    v_current_count NUMBER;
    v_capacity      NUMBER;
BEGIN
    -- 1. نجيبو شحال كاين دالطلبة مقبولين دابا وشحال هو الحد الأقصى
    SELECT 
        (SELECT COUNT(*) FROM inscription_request WHERE course_id = :NEW.course_id AND status = 'ACCEPTED'),
        capacity
    INTO v_current_count, v_capacity
    FROM course
    WHERE course_id = :NEW.course_id;

    -- 2. إلا كان العدد واصل للحد الأقصى، نمنعو العملية
    IF v_current_count >= v_capacity THEN
        RAISE_APPLICATION_ERROR(-20060, 'Echec inscription : Le cours a atteint sa capacité maximale (' || v_capacity || ')');
    END IF;
END;
/